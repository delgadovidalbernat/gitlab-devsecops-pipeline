# Security-as-a-Service for GitLab CI/CD
# This file is designed to be included in other pipelines
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE

variables:
  DEVSECOPS_IMAGE: "delgadovidalbernat/devsecops-tools:latest"
  # Default configuration. The pipeline including this file can override it
  DEVSECOPS_CONFIG: |
    secrets:
      enabled: true
      fail_on_detection: false
      redact: true
      exclude_paths: []
    sast:
      enabled: true
    sca:
      enabled: true
    dast:
      enabled: false

# Job that extracts configuration variables using yq
rules_variable_extractor:
  stage: .pre
  image: $DEVSECOPS_IMAGE
  script:
    - echo "Extracting variables from DEVSECOPS_CONFIG..."
    - FAIL_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.secrets.fail_on_detection // false')
    - echo "FAIL_ON_SECRET_DETECTION=$FAIL_VALUE" >> variables.env
    - echo "Variable extracted FAIL_ON_SECRET_DETECTION=$FAIL_VALUE"
  artifacts:
    reports:
      dotenv: variables.env

# Base template for all security jobs
.devsecops_template:
  stage: security
  image: $DEVSECOPS_IMAGE
  needs:
    - job: rules_variable_extractor
      artifacts: true
  before_script:
    - echo "$DEVSECOPS_CONFIG" > /tmp/devsecops-config.yml
    - echo "Configuration loaded:"
    - cat /tmp/devsecops-config.yml
  artifacts:
    expire_in: 1 week
    when: always

# Secret Detection job with GitLeaks
devsecops_secrets:
  extends: .devsecops_template
  script:
    - |
      echo "Starting secret detection with GitLeaks..."

      SECRETS_ENABLED=$(yq e '.secrets.enabled // true' /tmp/devsecops-config.yml)
      if [ "$SECRETS_ENABLED" != "true" ]; then
        echo "Secret detection disabled in configuration"
        echo '{"vulnerabilities": []}' > gl-secret-detection-report.json
        exit 0
      fi
      
      GITLEAKS_CMD="gitleaks detect --source . --report-format json --report-path gl-secret-detection-report.json --verbose"

      REDACT_ENABLED=$(yq e '.secrets.redact // true' /tmp/devsecops-config.yml)
      if [ "$REDACT_ENABLED" = "true" ]; then
        GITLEAKS_CMD="$GITLEAKS_CMD --redact"
      fi

      EXCLUDE_PATHS=$(yq e '.secrets.exclude_paths[]? // empty' /tmp/devsecops-config.yml)
      for path in $EXCLUDE_PATHS; do
        GITLEAKS_CMD="$GITLEAKS_CMD --exclude-path=$path"
      done
      
      echo "Running: $GITLEAKS_CMD"
      
      # Run GitLeaks command and capture exit code
      set +e
      eval $GITLEAKS_CMD
      GITLEAKS_EXIT_CODE=$?
      set -e
      
      # Ensure report exists
      if [ ! -f gl-secret-detection-report.json ]; then
        echo '{"vulnerabilities": []}' > gl-secret-detection-report.json
      fi
      
      FINDINGS_COUNT=$(jq '.vulnerabilities | length' gl-secret-detection-report.json 2>/dev/null || echo "0")
      
      if [ "$FINDINGS_COUNT" -gt 0 ]; then
        echo "Warning: $FINDINGS_COUNT secret(s) detected. Check the Security tab for details."
        
        echo ""
        echo "Summary of detected secrets:"
        jq -r '.vulnerabilities[] | "- \(.category): \(.location.file):\(.location.start_line)"' gl-secret-detection-report.json 2>/dev/null || echo "Could not parse findings"
        echo ""
        echo "Check the Security tab in Gitlab for detailed analysis."

        FAIL_ON_DETECTION=$(yq e '.secrets.fail_on_detection // false' /tmp/devsecops-config.yml)
        if [ "$FAIL_ON_DETECTION" = "true" ]; then
          echo "Pipeline configured to fail on secret detection"
          exit 1
        else
          echo "Pipeline continues despite secrets (fail_on_detection configured to false)"
        fi
      else
        echo "Success: No secrets detected"
      fi
  artifacts:
    reports:
      secret_detection: gl-secret-detection-report.json
  rules:
    - if: $CI_PIPELINE_SOURCE && $FAIL_ON_SECRET_DETECTION == "true"
      when: on_success
      allow_failure: false
    - if: $CI_PIPELINE_SOURCE
      when: on_success
      allow_failure: true
