# Security-as-a-Service for GitLab CI/CD
# This file is designed to be included in other pipelines
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE

variables:
  DEVSECOPS_IMAGE: "registry.gitlab.com/devsecops-hub/gitlab-devsecops-pipeline:latest"
  DEVSECOPS_CONFIG: |
    exclude_paths: []
    secrets:
      enabled: true
      fail_on_detection: false
      redact: true
      exclude_paths: []
    sast:
      enabled: true
      severity_threshold: "medium"  # low, medium, high
      languages: "auto"
      exclude_paths: []
      fail_on_detection: false
    sca:
      enabled: true
    dast:
      enabled: false

# Job that extracts configuration variables using yq
rules_variable_extractor:
  stage: .pre
  image: $DEVSECOPS_IMAGE
  script:
    - echo "Extracting variables from DEVSECOPS_CONFIG..."

    # Global exclude paths
    - GLOBAL_EXCLUDE_PATHS=$(echo "$DEVSECOPS_CONFIG" | yq e '.exclude_paths // [] | join(",")' -)
    - echo "GLOBAL_EXCLUDE_PATHS=$GLOBAL_EXCLUDE_PATHS" >> variables.env

    # Secret Detection
    - FAIL_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.secrets.fail_on_detection // false')
    - echo "FAIL_ON_SECRET_DETECTION=$FAIL_VALUE" >> variables.env
    - SECRETS_ENABLED_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.secrets.enabled // true')
    - echo "SECRETS_ENABLED=$SECRETS_ENABLED_VALUE" >> variables.env
    - SECRETS_REDACT_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.secrets.redact // true')
    - echo "SECRETS_REDACT=$SECRETS_REDACT_VALUE" >> variables.env

    # SAST
    - SAST_ENABLED_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.sast.enabled // true')
    - echo "SAST_ENABLED=$SAST_ENABLED_VALUE" >> variables.env
    - SAST_SEVERITY_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.sast.severity_threshold // "medium"')
    - echo "SAST_SEVERITY_THRESHOLD=$SAST_SEVERITY_VALUE" >> variables.env
    - SAST_LANGUAGES_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.sast.languages // "auto"')
    - echo "SAST_LANGUAGES=$SAST_LANGUAGES_VALUE" >> variables.env
    - SAST_FAIL_ON_DETECTION_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.sast.fail_on_detection // false')
    - echo "SAST_FAIL_ON_DETECTION=$SAST_FAIL_ON_DETECTION_VALUE" >> variables.env

    # SCA
    - SCA_ENABLED_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.sca.enabled // true')
    - echo "SCA_ENABLED=$SCA_ENABLED_VALUE" >> variables.env

    # DAST
    - DAST_ENABLED_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.dast.enabled // false')
    - echo "DAST_ENABLED=$DAST_ENABLED_VALUE" >> variables.env

    - echo "------------------------------------------"
    - echo "Variables extracted successfully:"
    - echo "Variable extracted FAIL_ON_SECRET_DETECTION=$FAIL_VALUE"
    - echo "Variable extracted SECRETS_ENABLED=$SECRETS_ENABLED_VALUE"
    - echo "Variable extracted SECRETS_REDACT=$SECRETS_REDACT_VALUE"
    - echo "Variable extracted SAST_ENABLED=$SAST_ENABLED_VALUE"
    - echo "Variable extracted SAST_SEVERITY_THRESHOLD=$SAST_SEVERITY_VALUE"
    - echo "Variable extracted SAST_LANGUAGES=$SAST_LANGUAGES_VALUE"
    - echo "Variable extracted SCA_ENABLED=$SCA_ENABLED_VALUE"
    - echo "Variable extracted DAST_ENABLED=$DAST_ENABLED_VALUE"
    - echo "------------------------------------------"

  artifacts:
    reports:
      dotenv: variables.env

# Base template for all security jobs
.devsecops_template:
  stage: security
  image: $DEVSECOPS_IMAGE
  needs:
    - job: rules_variable_extractor
      artifacts: true
  before_script:
    - |
      combine_exclude_paths() {
        local tool_name=$1
        local global_paths="$GLOBAL_EXCLUDE_PATHS"
        local tool_specific_paths=$(yq e ".${tool_name}.exclude_paths // [] | join(\",\")" /tmp/devsecops-config.yml)
        
        if [ -n "$global_paths" ] && [ -n "$tool_specific_paths" ]; then
            echo "${global_paths},${tool_specific_paths}"
        elif [ -n "$global_paths" ]; then
            echo "$global_paths"
        elif [ -n "$tool_specific_paths" ]; then
            echo "$tool_specific_paths"
        else
            echo ""
        fi
      }

    - echo "$DEVSECOPS_CONFIG" > /tmp/devsecops-config.yml
    - echo "Configuration loaded:"
    - cat /tmp/devsecops-config.yml
  artifacts:
    expire_in: 1 week
    when: always

# Secret Detection job with GitLeaks
devsecops_secrets:
  extends: .devsecops_template
  script:
    - |
      echo "Starting secret detection with GitLeaks..."

      COMBINED_EXCLUDE_PATHS=$(combine_exclude_paths "secrets")
      echo "Combined exclude paths: $COMBINED_EXCLUDE_PATHS"

      GITLEAKS_RAW_REPORT="gitleaks-raw-report.json"
      GITLEAKS_HTML_REPORT="gitleaks-report.html"
      GITLEAKS_HTML_TEMPLATE="/usr/local/share/gitleaks/templates/gitlab-html-report.tmpl"

      if [ "$SECRETS_ENABLED" != "true" ]; then
        echo "Secret detection disabled in configuration"
        echo '[]' > "${GITLEAKS_RAW_REPORT}"
        exit 0
      fi

      GITLEAKS_BASE_CMD="gitleaks detect"

      if [ "$SECRETS_REDACT" = "true" ]; then
        GITLEAKS_BASE_CMD="$GITLEAKS_BASE_CMD --redact"
      fi

      # Start exclude path process
      EXCLUDE_PATHS=$(yq e '.secrets.exclude_paths // [] | .[]' /tmp/devsecops-config.yml)
      GITLEAKS_CONFIG_PATH=".gitleaks.toml"

      echo "title = 'Auto-generated config for Gitleaks'" > $GITLEAKS_CONFIG_PATH
      echo "[extend]" >> $GITLEAKS_CONFIG_PATH
      echo "useDefault = true" >> $GITLEAKS_CONFIG_PATH

      if [ -n "$COMBINED_EXCLUDE_PATHS" ]; then
        echo "" >> $GITLEAKS_CONFIG_PATH
        echo "[[allowlists]]" >> $GITLEAKS_CONFIG_PATH
        echo 'description = "Paths excluded from secret detection"' >> $GITLEAKS_CONFIG_PATH
        echo "paths = [" >> $GITLEAKS_CONFIG_PATH

        echo "$COMBINED_EXCLUDE_PATHS" | tr ',' '\n' | while read -r path; do
          if [ -n "$path" ]; then
              echo "  '''${path}'''," >> $GITLEAKS_CONFIG_PATH
          fi
        done

        echo "]" >> $GITLEAKS_CONFIG_PATH
      else
        echo "No exclude_paths defined, using default rules only."
      fi
      
      GITLEAKS_CMD_RAW="${GITLEAKS_BASE_CMD} --config ${GITLEAKS_CONFIG_PATH} --report-format json --report-path ${GITLEAKS_RAW_REPORT} --verbose"

      echo "Running raw report generation: $GITLEAKS_CMD_RAW"
      
      set +e
      eval $GITLEAKS_CMD_RAW
      GITLEAKS_EXIT_CODE=$?
      set -e

      if [ ! -f "${GITLEAKS_RAW_REPORT}" ]; then
        echo '[]' > "${GITLEAKS_RAW_REPORT}"
      fi

      # Convert raw Gitleaks report to GitLab Secret Detection Report format.
      jq -c '{
        "vulnerabilities": (
          map({
            id: .Fingerprint,
            category: "secret_detection",
            name: .Description,
            description: "Secret detected by Gitleaks.\nRule: `\(.RuleID)`.\nFile: `\(.File)`.\nLine: `\(.StartLine)`.\nCommit: `\(.Commit[0:7])` by `\(.Author)`.\nCommit Message: \"\(.Message)\".",
            severity: "High", # You might want to map this based on RuleID for different severities
            confidence: "High",
            scanner: {
              id: "gitleaks",
              name: "Gitleaks"
            },
            location: {
              file: .File,
              start_line: .StartLine,
              end_line: .EndLine,
              commit: {
                sha: .Commit
              }
            },
            identifiers: [
              {
                type: "gitleaks_rule_id",
                name: "Gitleaks Rule ID: \(.RuleID)",
                value: .RuleID
              }
            ]
          })
        )
      }' "${GITLEAKS_RAW_REPORT}" > gl-secret-detection-report.json 2>/dev/null || echo "Error converting Gitleaks report to GitLab format."

      # Reexecute the command to generate HTML report.
      GITLEAKS_CMD_HTML="${GITLEAKS_BASE_CMD} --config ${GITLEAKS_CONFIG_PATH} --report-format template --report-template ${GITLEAKS_HTML_TEMPLATE} --report-path ${GITLEAKS_HTML_REPORT} --verbose"
      echo "Running HTML report generation: $GITLEAKS_CMD_HTML"
      set +e
      eval $GITLEAKS_CMD_HTML
      GITLEAKS_EXIT_CODE_HTML=$?
      set -e

      if [ ! -f "${GITLEAKS_HTML_REPORT}" ]; then
          echo "Warning: HTML report was not generated. Creating a placeholder HTML report."
          echo '<html><body><h1>Report Generation Failed</h1><p>The HTML report could not be generated.</p></body></html>' > "${GITLEAKS_HTML_REPORT}"
      fi
      
      FINDINGS_COUNT=$(jq '.vulnerabilities | length' gl-secret-detection-report.json 2>/dev/null || echo "0")
      
      if [ "$FINDINGS_COUNT" -gt 0 ]; then
        echo "Warning: $FINDINGS_COUNT secret(s) detected. Check the Security tab for details."
        
        echo ""
        echo "----------------------------------------------------"
        echo "Summary of Detected Secrets:"
        jq -r '.vulnerabilities[] | "- \(.name): \(.location.file):\(.location.start_line) (Commit: \(.location.commit.sha[0:7]) by \(.description | capture("by `(?<author>[^`]+)`").author))"' gl-secret-detection-report.json 2>/dev/null || echo "Could not parse findings for summary."
        echo "----------------------------------------------------"
        echo ""

        echo "Check the Security tab in Gitlab for detailed analysis."

        if [ "$FAIL_ON_SECRET_DETECTION" = "true" ]; then
          echo "Pipeline configured to fail on secret detection"
          exit 1
        else
          echo "Pipeline continues despite secrets (fail_on_detection configured to false)"
        fi
      else
        echo "Success: No secrets detected"
      fi
  artifacts:
    expire_in: 1 week
    when: always
    paths:
      - gitleaks-raw-report.json
      - gitleaks-report.html
      - .gitleaks.toml
    reports:
      secret_detection: gl-secret-detection-report.json
  rules:
    - if: $CI_PIPELINE_SOURCE && $FAIL_ON_SECRET_DETECTION == "true"
      when: on_success
      allow_failure: false
    - if: $CI_PIPELINE_SOURCE
      when: on_success
      allow_failure: true

devsecops_sast:
  extends: .devsecops_template
  script:
    - |
      echo "Starting SAST analysis with Semgrep..."

      COMBINED_EXCLUDE_PATHS=$(combine_exclude_paths "sast")
      echo "Combined exclude paths: $COMBINED_EXCLUDE_PATHS"
      
      SEMGREP_IGNORE_FILE=".semgrepignore"
      SEMGREP_RAW_REPORT="semgrep-raw-report.json"
      
      if [ "$SAST_ENABLED" != "true" ]; then
        echo "SAST analysis disabled in configuration"
        echo '{"vulnerabilities": []}' > gl-sast-report.json
        exit 0
      fi
      
      SEMGREP_CMD="semgrep --gitlab-sast --oss-only --config=auto --json --output=gl-sast-report.json"

      if [ "$SAST_FAIL_ON_DETECTION" = "true" ]; then
        SEMGREP_CMD="$SEMGREP_CMD --error"
      fi
      
      case "$SAST_SEVERITY_THRESHOLD" in
        "low")
          SEMGREP_CMD="$SEMGREP_CMD --severity=INFO --severity=WARNING --severity=ERROR"
          ;;
        "medium")
          SEMGREP_CMD="$SEMGREP_CMD --severity=WARNING --severity=ERROR"
          ;;
        "high")
          SEMGREP_CMD="$SEMGREP_CMD --severity=ERROR"
          ;;
      esac
      
      # Auto-detect languages if needed.
      if [ "$SAST_LANGUAGES" = "auto" ]; then
        echo "Auto-detecting project languages..."
        
        if [ -f "package.json" ]; then
          echo "Detected JavaScript/Node.js project"
          SEMGREP_CMD="$SEMGREP_CMD --config=p/javascript --config=p/typescript --config=p/react --config=p/nextjs --config=p/nodejs"
        fi
        
        if [ -f "go.mod" ]; then
          echo "Detected Go project" 
          SEMGREP_CMD="$SEMGREP_CMD --config=p/golang --config=p/gosec"
        fi
        
        if [ -f "requirements.txt" ] || [ -f "pyproject.toml" ] || [ -f "setup.py" ]; then
          echo "Detected Python project"
          SEMGREP_CMD="$SEMGREP_CMD --config=p/python --config=p/fastapi --config=p/flask --config=p/django"
        fi
        
        if [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
          echo "Detected Java project"
          SEMGREP_CMD="$SEMGREP_CMD --config=p/java"
        fi

        if [ -f "Dockerfile" ]; then
          echo "Detected Docker project"
          SEMGREP_CMD="$SEMGREP_CMD --config=p/dockerfile  --config=p/docker-compose"
        fi

        if [ -f "Gemfile" ]; then
          echo "Detected Ruby project"
          SEMGREP_CMD="$SEMGREP_CMD --config=p/ruby"
        fi

        if [ -f "Cargo.toml" ]; then
          echo "Detected Rust project"
          SEMGREP_CMD="$SEMGREP_CMD --config=p/rust"
        fi

        if [ -f "composer.json" ]; then
          echo "Detected PHP project"
          SEMGREP_CMD="$SEMGREP_CMD --config=p/php"
        fi

        if [ -f "build.sbt" ]; then
          echo "Detected Scala project"
          SEMGREP_CMD="$SEMGREP_CMD --config=p/scala"
        fi

        SEMGREP_CMD="$SEMGREP_CMD --config=p/security-audit --config=p/owasp-top-ten --config=p/cwe-top-25 --config=p/play --config=p/jwt --config=p/findsecbugs --config=p/sql-injection --config=p/command-injection --config=p/xss"
      fi
      
     
      # Create .semgrepignore file with exclude paths
      echo "# Auto-generated .semgrepignore file for Semgrep SAST analysis" > $SEMGREP_IGNORE_FILE
      echo "# Default excludes" >> $SEMGREP_IGNORE_FILE
      echo "node_modules/" >> $SEMGREP_IGNORE_FILE
      echo ".git/" >> $SEMGREP_IGNORE_FILE
      echo "vendor/" >> $SEMGREP_IGNORE_FILE
      echo "build/" >> $SEMGREP_IGNORE_FILE
      echo "dist/" >> $SEMGREP_IGNORE_FILE
      echo "*.min.js" >> $SEMGREP_IGNORE_FILE
      echo "*.bundle.js" >> $SEMGREP_IGNORE_FILE
      
      # Add user-defined exclude paths

      if [ -n "$COMBINED_EXCLUDE_PATHS" ]; then
        echo "" >> $SEMGREP_IGNORE_FILE
        echo "# Combined exclude paths" >> $SEMGREP_IGNORE_FILE

        echo "$COMBINED_EXCLUDE_PATHS" | tr ',' '\n' | while read -r path; do
          if [ -n "$path" ]; then
              echo "$path" >> $SEMGREP_IGNORE_FILE
          fi
        done
      else
        echo "No combined exclude_paths defined, using default rules only."
      fi

      echo "Generated .semgrepignore file:"
      cat $SEMGREP_IGNORE_FILE
      
      echo "Running Semgrep: $SEMGREP_CMD"
      
      # Run Semgrep
      set +e
      eval $SEMGREP_CMD .
      SEMGREP_EXIT_CODE=$?
      set -e
      
      # Ensure report exists
      if [ ! -f "gl-sast-report.json" ]; then
        echo '{"results": []}' > "gl-sast-report.json"
      fi

      # Report results
      FINDINGS_COUNT=$(jq '.vulnerabilities | length' gl-sast-report.json 2>/dev/null || echo "0")
      
      if [ "$FINDINGS_COUNT" -gt 0 ]; then
        echo "Warning: $FINDINGS_COUNT SAST finding(s) detected."
        echo ""
        echo "----------------------------------------------------"
        echo "Summary of SAST Findings:"
        jq -r '.vulnerabilities[] | "- \(.severity): \(.name) in \(.location.file):\(.location.start_line)"' gl-sast-report.json 2>/dev/null || echo "Could not parse findings for summary."
        echo "----------------------------------------------------"
        echo ""
        echo "Check the Security tab in GitLab for detailed analysis."
      else
        echo "OK - Success: No SAST issues detected"
      fi
  artifacts:
    expire_in: 1 week
    when: always
    paths:
      - semgrep-raw-report.json
      - .semgrepignore
    reports:
      sast: gl-sast-report.json
  rules:
    - if: $CI_PIPELINE_SOURCE
      when: on_success
      allow_failure: true
