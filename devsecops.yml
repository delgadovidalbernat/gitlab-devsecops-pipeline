# Security-as-a-Service for GitLab CI/CD
# This file is designed to be included in other pipelines
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE

variables:
  DEVSECOPS_IMAGE: "delgadovidalbernat/devsecops-tools:latest"
  # Default configuration. The pipeline including this file can override it
  DEVSECOPS_CONFIG: |
    secrets:
      enabled: true
      fail_on_detection: false
      redact: true
      exclude_paths: []
    sast:
      enabled: true
    sca:
      enabled: true
    dast:
      enabled: false

# Job that extracts configuration variables using yq
rules_variable_extractor:
  stage: .pre
  image: $DEVSECOPS_IMAGE
  script:
    - echo "Extracting variables from DEVSECOPS_CONFIG..."

    # Secret Detection
    - FAIL_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.secrets.fail_on_detection // false')
    - echo "FAIL_ON_SECRET_DETECTION=$FAIL_VALUE" >> variables.env
    - echo "Variable extracted FAIL_ON_SECRET_DETECTION=$FAIL_VALUE"

    - SECRETS_ENABLED_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.secrets.enabled // true')
    - echo "SECRETS_ENABLED=$SECRETS_ENABLED_VALUE" >> variables.env
    - echo "Variable extracted SECRETS_ENABLED=$SECRETS_ENABLED_VALUE"

    - SECRETS_REDACT_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.secrets.redact // true')
    - echo "SECRETS_REDACT=$SECRETS_REDACT_VALUE" >> variables.env
    - echo "Variable extracted SECRETS_REDACT=$SECRETS_REDACT_VALUE"

    # SAST
    - SAST_ENABLED_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.sast.enabled // true')
    - echo "SAST_ENABLED=$SAST_ENABLED_VALUE" >> variables.env
    - echo "Variable extracted SAST_ENABLED=$SAST_ENABLED_VALUE"

    # SCA
    - SCA_ENABLED_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.sca.enabled // true')
    - echo "SCA_ENABLED=$SCA_ENABLED_VALUE" >> variables.env
    - echo "Variable extracted SCA_ENABLED=$SCA_ENABLED_VALUE"

    # DAST
    - DAST_ENABLED_VALUE=$(echo "$DEVSECOPS_CONFIG" | yq e '.dast.enabled // false')
    - echo "DAST_ENABLED=$DAST_ENABLED_VALUE" >> variables.env
    - echo "Variable extracted DAST_ENABLED=$DAST_ENABLED_VALUE"

  artifacts:
    reports:
      dotenv: variables.env

# Base template for all security jobs
.devsecops_template:
  stage: security
  image: $DEVSECOPS_IMAGE
  needs:
    - job: rules_variable_extractor
      artifacts: true
  before_script:
    - echo "$DEVSECOPS_CONFIG" > /tmp/devsecops-config.yml
    - echo "Configuration loaded:"
    - cat /tmp/devsecops-config.yml
  artifacts:
    expire_in: 1 week
    when: always

# Secret Detection job with GitLeaks
devsecops_secrets:
  extends: .devsecops_template
  script:
    - |
      echo "Starting secret detection with GitLeaks..."

      GITLEAKS_RAW_REPORT="gitleaks-raw-report.json"

      if [ "$SECRETS_ENABLED" != "true" ]; then
        echo "Secret detection disabled in configuration"
        echo '[]' > "${GITLEAKS_RAW_REPORT}"
        exit 0
      fi

      GITLEAKS_CMD="gitleaks detect --source . --report-format json --report-path ${GITLEAKS_RAW_REPORT} --verbose"

      if [ "$SECRETS_REDACT" = "true" ]; then
        GITLEAKS_CMD="$GITLEAKS_CMD --redact"
      fi

      EXCLUDE_PATHS=$(yq e '.secrets.exclude_paths[]? // [] | .[]' /tmp/devsecops-config.yml)
      for path in $EXCLUDE_PATHS; do
        GITLEAKS_CMD="$GITLEAKS_CMD --exclude-path=$path"
      done
      
      echo "Running: $GITLEAKS_CMD"
      
      # Run GitLeaks command and capture exit code
      set +e
      eval $GITLEAKS_CMD
      GITLEAKS_EXIT_CODE=$?
      set -e

      if [ ! -f "${GITLEAKS_RAW_REPORT}" ]; then
        echo '[]' > "${GITLEAKS_RAW_REPORT}"
      fi

      # Convert raw Gitleaks report to GitLab Secret Detection Report format.
      jq -c '{
        "vulnerabilities": (
          map({
            id: .Fingerprint,
            category: "secret_detection",
            name: .Description,
            description: "Secret detected by Gitleaks.\nRule: `\(.RuleID)`.\nFile: `\(.File)`.\nLine: `\(.StartLine)`.\nCommit: `\(.Commit[0:7])` by `\(.Author)`.\nCommit Message: \"\(.Message)\".",
            severity: "High", # You might want to map this based on RuleID for different severities
            confidence: "High",
            scanner: {
              id: "gitleaks",
              name: "Gitleaks"
            },
            location: {
              file: .File,
              start_line: .StartLine,
              end_line: .EndLine,
              commit: {
                sha: .Commit
              }
            },
            identifiers: [
              {
                type: "gitleaks_rule_id",
                name: "Gitleaks Rule ID: \(.RuleID)",
                value: .RuleID
              }
            ]
          })
        )
      }' "${GITLEAKS_RAW_REPORT}" > gl-secret-detection-report.json 2>/dev/null || echo "Error converting Gitleaks report to GitLab format."
      
      FINDINGS_COUNT=$(jq '.vulnerabilities | length' gl-secret-detection-report.json 2>/dev/null || echo "0")
      
      if [ "$FINDINGS_COUNT" -gt 0 ]; then
        echo "Warning: $FINDINGS_COUNT secret(s) detected. Check the Security tab for details."
        
        echo ""
        echo "----------------------------------------------------"
        echo "Summary of Detected Secrets:"
        jq -r '.vulnerabilities[] | "- \(.name): \(.location.file):\(.location.start_line) (Commit: \(.location.commit.sha[0:7]) by \(.description | capture("by `(?<author>[^`]+)`").author))"' gl-secret-detection-report.json 2>/dev/null || echo "Could not parse findings for summary."
        echo "----------------------------------------------------"
        echo ""

        echo "Check the Security tab in Gitlab for detailed analysis."

        if [ "$FAIL_ON_SECRET_DETECTION" = "true" ]; then
          echo "Pipeline configured to fail on secret detection"
          exit 1
        else
          echo "Pipeline continues despite secrets (fail_on_detection configured to false)"
        fi
      else
        echo "Success: No secrets detected"
      fi
  artifacts:
    expire_in: 1 week
    when: always
    paths:
      - gitleaks-raw-report.json
    reports:
      secret_detection: gl-secret-detection-report.json
  rules:
    - if: $CI_PIPELINE_SOURCE && $FAIL_ON_SECRET_DETECTION == "true"
      when: on_success
      allow_failure: false
    - if: $CI_PIPELINE_SOURCE
      when: on_success
      allow_failure: true
